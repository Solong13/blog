<?php

namespace SoLong\Blog\model;

                          //  Спосіб Підключення до БД №1
/*
Так, PDO (PHP Data Objects) - це розширення, яке входить до складу PHP. Ви можете використовувати його без потреби 
в явному завантаженні або встановленні через Composer. По замовчуванню, воно доступне у PHP.
Однак, важливо враховувати, що ваш код повинен бути налаштований правильно, і це розширення повинно 
бути активовано у конфігураційному файлі PHP. Для роботи з базою даних із використанням PDO, ви повинні 
також встановити відповідний драйвер бази даних, який вам потрібен (наприклад, PDO MySQL, PDO SQLite і т. д.).
Ваш сервер і конфігурація PHP повинні бути налаштовані на підтримку цього розширення. Будьте обережні і переконайтеся,
 що PDO активовано і налаштовано в вашому серверному середовищі перед використанням його у своєму коді.
Здається, що ви вже працюєте над організацією коду в стилі ООП та шаблонному програмуванні MVC, і це гарно. Давайте зробимо короткий огляд того, що ви вже зробили та що можна покращити:

Розділення на класи та файли: Ви розділили код на різні класи та файли, що полегшує управління та розуміння коду.

Ін'єкція залежностей: Ви використовуєте ін'єкцію залежностей для передачі об'єкта підключення до бази даних (con_DB) до класу Db_reguests_with_DI. Це дозволяє полегшити тестування та забезпечує більшу гнучкість.

Методи моделі для роботи з базою даних: Ви вже розділили логіку роботи з базою даних в окремий клас Db_reguests_with_DI, що є доброю практикою для розділення відповідальностей у шаблоні MVC.

Однак є деякі покращення, які можна внести:

Відокремлення коду обробки помилок: Замість виведення повідомлення про помилку на екран, слід використовувати винятки (try-catch) для обробки помилок та логування. Це зробить ваш код більш підтримуваним.

Можливість зміни параметрів підключення: Замість жорстко закодованих параметрів підключення до бази даних (наприклад, ім'я користувача та пароль), можна розглянути можливість зберігання цих параметрів у конфігураційних файлах та передавати їх як аргументи при створенні об'єкту con_DB.

Винесення запитів SQL в окремі методи: Щоб полегшити читання та обслуговування коду, ви можете розглянути винесення запитів SQL в окремі методи класу Db_reguests_with_DI. Це дозволить легше розширювати функціональність та обслуговувати запити.

Обробка помилок при виконанні запитів: Додайте обробку помилок при виконанні запитів до бази даних. Це дозволить більш коректно обробляти помилки та повідомлення про них.

Можливість вставки, оновлення та видалення в один метод: У методі Db_reguests_with_DI ви можете розглянути можливість створити загальний метод для вставки, оновлення та видалення, що приймає параметри для визначення типу запиту.

Загалом, ваш підхід до ООП та шаблонного програмування MVC є правильним. Продовжуйте вдосконалювати та оптимізовувати свій код для досягнення кращої читабельності, підтримуваності та розширюваності.Здається, що ви вже працюєте над організацією коду в стилі ООП та шаблонному програмуванні MVC, і це гарно. Давайте зробимо короткий огляд того, що ви вже зробили та що можна покращити:

Розділення на класи та файли: Ви розділили код на різні класи та файли, що полегшує управління та розуміння коду.

Ін'єкція залежностей: Ви використовуєте ін'єкцію залежностей для передачі об'єкта підключення до бази даних (con_DB) до класу Db_reguests_with_DI. Це дозволяє полегшити тестування та забезпечує більшу гнучкість.

Методи моделі для роботи з базою даних: Ви вже розділили логіку роботи з базою даних в окремий клас Db_reguests_with_DI, що є доброю практикою для розділення відповідальностей у шаблоні MVC.

Однак є деякі покращення, які можна внести:

Відокремлення коду обробки помилок: Замість виведення повідомлення про помилку на екран, слід використовувати винятки (try-catch) для обробки помилок та логування. Це зробить ваш код більш підтримуваним.

Можливість зміни параметрів підключення: Замість жорстко закодованих параметрів підключення до бази даних (наприклад, ім'я користувача та пароль), можна розглянути можливість зберігання цих параметрів у конфігураційних файлах та передавати їх як аргументи при створенні об'єкту con_DB.

Винесення запитів SQL в окремі методи: Щоб полегшити читання та обслуговування коду, ви можете розглянути винесення запитів SQL в окремі методи класу Db_reguests_with_DI. Це дозволить легше розширювати функціональність та обслуговувати запити.

Обробка помилок при виконанні запитів: Додайте обробку помилок при виконанні запитів до бази даних. Це дозволить більш коректно обробляти помилки та повідомлення про них.

Можливість вставки, оновлення та видалення в один метод: У методі Db_reguests_with_DI ви можете розглянути можливість створити загальний метод для вставки, оновлення та видалення, що приймає параметри для визначення типу запиту.

Загалом, ваш підхід до ООП та шаблонного програмування MVC є правильним. Продовжуйте вдосконалювати та оптимізовувати свій код для досягнення кращої читабельності, підтримуваності та розширюваності.
 */
/* 
если расписать  подробнее:
1. Настройки соединения не должны быть свойствами класса. Свойство должно как-то использоваться в классе. А здесь это одноразовые переменные
2. Конкретные значения не должны прописываться в коде класса, они на всех серверах будут разные. Они должны идти из настроек
3. Никакого echo здесь быть не должно. Код соединения с БД не должен общаться напрямую с пользователем. 
4. Не говоря уже о вываливании информации об ошибке на всеобщее обозрение
5. Соответственно, try-catch тоже не нужно
И в итоге получается, что всего кода тут должно быть 2 строчки, если без получения настроек. 
$dbh = new PDO("mysql:host={$dbHost};dbname={$dbName};charset=utf8mb4", $dbUserName, $dbPassword);
$dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
(кодировка тоже указывается в DSN)
*/

// фабричний метод i DI
use  PDO;

class con_DB  {
    //зберігати підключення до бази даних.
    private $dbh;
    private $dsn;
    private $params;

    // public function __construct($driver, $dbHost, $dbUserName, $dbPassword, $dbName, $charset)
    // {
    //     $this->params['driver'] = $driver;
    //     $this->params['host'] = $dbHost;
    //     $this->params['login'] = $dbUserName;
    //     $this->params['password'] = $dbPassword;
    //     $this->params['database'] = $dbName;
    //     $this->params['charset'] = $charset;
    // }

    // 2 варіанти підключення з викиданням помилок і ні
    public function connect(){
        try {
            //В даному рядку відбувається створення об'єкта PDO і підключення до бази даних
             $this->dbh = new PDO("mysql:host={$dbHost};dbname={$dbName}", $dbUserName, $dbPassword);
            //Встановлюємо атрибути об'єкта PDO для обробки помилок і встановлюємо режим обробки помилок в режим. Вираз PDO:: вказує на те, що ця константа належить класу PDO.
            $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            // Задаємо кодування
            $this->dbh->exec('SET NAMES UTF8');
        } catch (PDOException $e) {
            echo 'Connection failed: ' . $e->getMessage();
        }

    }

    public function getPDO() {
        return $this->dbh;
    }

    public function сonnectionToDataBase()
    {
        $options = [
            //Встановлюємо атрибути об'єкта PDO для обробки помилок і встановлюємо режим обробки помилок в режим. Вираз PDO:: вказує на те, що ця константа належить класу PDO.
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_STRINGIFY_FETCHES => false,
            PDO::ATTR_EMULATE_PREPARES => false
        ];
        
        $dsn = "mysql:host=localhost;dbname=test;charset=utf8mb4";
        //$dsn = "$this->params['driver']:host=$this->params['host'];dbname=$this->params['database'];charset=$this->params['charset']";
        return new PDO($dsn,  'root', '', $options);
    }

}
